{"version":3,"file":"ruler.min.js","sources":["../../react-ruler/dist/ruler.esm.js","../src/index.umd.ts","../src/consts.ts","../src/InnerRuler.tsx","../src/Ruler.tsx"],"sourcesContent":["/*\nCopyright (c) 2019 Daybrush\nname: @scena/react-ruler\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/ruler/blob/master/packages/react-ruler\nversion: 0.19.0\n*/\nimport { createElement, PureComponent } from 'react';\nimport { ref } from 'framework-utils';\nimport { convertUnitSize, findLast } from '@daybrush/utils';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar Ruler =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Ruler, _super);\n\n  function Ruler() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      scrollPos: 0\n    };\n    _this.width = 0;\n    _this.height = 0;\n    _this._zoom = 0;\n    _this._rulerScale = 0;\n    _this._observer = null;\n\n    _this._checkResize = function () {\n      _this.resize();\n    };\n\n    return _this;\n  }\n\n  var __proto = Ruler.prototype;\n\n  __proto.render = function () {\n    var props = this.props;\n    this._zoom = props.zoom;\n    return createElement(\"canvas\", {\n      ref: ref(this, \"canvasElement\"),\n      style: this.props.style\n    });\n  };\n\n  __proto.componentDidMount = function () {\n    var props = this.props;\n    this.state.scrollPos = props.defaultScrollPos || 0;\n    var canvas = this.canvasElement;\n    var context = canvas.getContext(\"2d\", {\n      alpha: true\n    });\n    this.canvasContext = context;\n\n    if (props.useResizeObserver) {\n      this._observer = new ResizeObserver(this._checkResize);\n\n      this._observer.observe(canvas, {\n        box: \"border-box\"\n      });\n    } else {\n      this.resize();\n    }\n  };\n\n  __proto.componentDidUpdate = function () {\n    this.resize();\n  };\n\n  __proto.componentWillUnmount = function () {\n    var _a;\n\n    this.state.scrollPos = 0;\n    (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();\n  };\n  /**\n   * Gets the scroll position of the ruler.\n   */\n\n\n  __proto.getScrollPos = function () {\n    return this.state.scrollPos;\n  };\n  /**\n   * @method Ruler#scroll\n   * @param scrollPos\n   */\n\n\n  __proto.scroll = function (scrollPos, zoom) {\n    this.draw({\n      scrollPos: scrollPos,\n      zoom: zoom\n    });\n  };\n  /**\n   * @method Ruler#resize\n   */\n\n\n  __proto.resize = function (nextZoom) {\n    var canvas = this.canvasElement;\n    var _a = this.props,\n        width = _a.width,\n        height = _a.height,\n        scrollPos = _a.scrollPos;\n\n    var rulerScale = this._getRulerScale();\n\n    this.width = width || canvas.offsetWidth;\n    this.height = height || canvas.offsetHeight;\n    canvas.width = this.width * rulerScale;\n    canvas.height = this.height * rulerScale;\n    this.draw({\n      scrollPos: scrollPos,\n      zoom: nextZoom\n    });\n  };\n  /**\n   * draw a ruler\n   * @param options - It is drawn with an external value, not the existing state.\n   */\n\n\n  __proto.draw = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var props = this.props;\n    var _a = options.zoom,\n        nextZoom = _a === void 0 ? this._zoom : _a,\n        _b = options.scrollPos,\n        scrollPos = _b === void 0 ? this.state.scrollPos : _b,\n        _c = options.marks,\n        marks = _c === void 0 ? props.marks : _c,\n        _d = options.selectedRanges,\n        selectedRanges = _d === void 0 ? props.selectedRanges : _d,\n        _e = options.segment,\n        segment = _e === void 0 ? props.segment || 10 : _e,\n        _f = options.unit,\n        unit = _f === void 0 ? props.unit : _f;\n    this._zoom = nextZoom;\n    var _g = props,\n        type = _g.type,\n        backgroundColor = _g.backgroundColor,\n        lineColor = _g.lineColor,\n        textColor = _g.textColor,\n        textBackgroundColor = _g.textBackgroundColor,\n        direction = _g.direction,\n        _h = _g.negativeRuler,\n        negativeRuler = _h === void 0 ? true : _h,\n        textFormat = _g.textFormat,\n        _j = _g.range,\n        range = _j === void 0 ? [-Infinity, Infinity] : _j,\n        rangeBackgroundColor = _g.rangeBackgroundColor,\n        selectedBackgroundColor = _g.selectedBackgroundColor,\n        _k = _g.lineWidth,\n        lineWidth = _k === void 0 ? 1 : _k,\n        selectedRangesText = _g.selectedRangesText,\n        _l = _g.selectedRangesTextColor,\n        selectedRangesTextColor = _l === void 0 ? \"#44aaff\" : _l,\n        _m = _g.selectedRangesTextOffset,\n        selectedRangesTextOffset = _m === void 0 ? [0, 0] : _m,\n        _o = _g.markColor,\n        markColor = _o === void 0 ? \"#ff5\" : _o;\n\n    var rulerScale = this._getRulerScale();\n\n    var width = this.width;\n    var height = this.height;\n    var state = this.state;\n    state.scrollPos = scrollPos;\n    var context = this.canvasContext;\n    var isHorizontal = type === \"horizontal\";\n    var isNegative = negativeRuler !== false;\n    var font = props.font || \"10px sans-serif\";\n    var textAlign = props.textAlign || \"left\";\n    var textOffset = props.textOffset || [0, 0];\n    var containerSize = isHorizontal ? height : width;\n    var mainLineSize = convertUnitSize(\"\".concat(props.mainLineSize || \"100%\"), containerSize);\n    var longLineSize = convertUnitSize(\"\".concat(props.longLineSize || 10), containerSize);\n    var shortLineSize = convertUnitSize(\"\".concat(props.shortLineSize || 7), containerSize);\n    var lineOffset = props.lineOffset || [0, 0];\n\n    if (backgroundColor === \"transparent\") {\n      // Clear existing paths & text\n      context.clearRect(0, 0, width * rulerScale, height * rulerScale);\n    } else {\n      // Draw the background\n      context.rect(0, 0, width * rulerScale, height * rulerScale);\n      context.fillStyle = backgroundColor;\n      context.fill();\n    }\n\n    context.save();\n    context.scale(rulerScale, rulerScale);\n    context.strokeStyle = lineColor;\n    context.lineWidth = lineWidth;\n    context.font = font;\n    context.fillStyle = textColor;\n    context.textAlign = textAlign;\n\n    switch (direction) {\n      case \"start\":\n        context.textBaseline = \"top\";\n        break;\n\n      case \"center\":\n        context.textBaseline = \"middle\";\n        break;\n\n      case \"end\":\n        context.textBaseline = \"bottom\";\n        break;\n    }\n\n    context.translate(0.5, 0);\n    context.beginPath();\n    var size = isHorizontal ? width : height;\n    var zoomUnit = nextZoom * unit;\n    var minRange = Math.floor(scrollPos * nextZoom / zoomUnit);\n    var maxRange = Math.ceil((scrollPos * nextZoom + size) / zoomUnit);\n    var length = maxRange - minRange;\n    var alignOffset = Math.max([\"left\", \"center\", \"right\"].indexOf(textAlign) - 1, -1);\n    var barSize = isHorizontal ? height : width;\n    var values = [];\n\n    for (var i = 0; i <= length; ++i) {\n      var value = (i + minRange) * unit;\n      var text = \"\".concat(value);\n\n      if (textFormat) {\n        text = textFormat(value);\n      }\n\n      var textSize = context.measureText(text).width;\n      values.push({\n        color: textColor,\n        offset: textOffset,\n        backgroundColor: textBackgroundColor,\n        value: value,\n        text: text,\n        textSize: textSize\n      });\n    } // Draw Selected Range Background\n\n\n    if (selectedBackgroundColor !== \"transparent\" && (selectedRanges === null || selectedRanges === void 0 ? void 0 : selectedRanges.length)) {\n      selectedRanges.forEach(function (selectedRange) {\n        var rangeStart = Math.max(selectedRange[0], range[0], negativeRuler ? -Infinity : 0);\n        var rangeEnd = Math.min(selectedRange[1], range[1]);\n        var rangeX = (rangeStart - scrollPos) * nextZoom;\n        var rangeWidth = (rangeEnd - rangeStart) * nextZoom;\n\n        if (selectedRangesText) {\n          selectedRange.forEach(function (value) {\n            var text = \"\".concat(value);\n\n            if (textFormat) {\n              text = textFormat(value);\n            }\n\n            var textSize = context.measureText(text).width;\n            var startPos = value * nextZoom;\n            var endPos = startPos + textSize;\n            findLast(values, function (_a, index) {\n              var prevValue = _a.value,\n                  prevTextSize = _a.textSize;\n              var prevStartPos = prevValue * nextZoom;\n              var prevEndPos = prevStartPos + prevTextSize;\n\n              if (prevStartPos <= endPos && startPos <= prevEndPos) {\n                values.splice(index, 1);\n              }\n            });\n            values.push({\n              value: value,\n              color: selectedRangesTextColor,\n              offset: selectedRangesTextOffset,\n              text: text,\n              textSize: textSize\n            });\n          });\n        }\n\n        if (rangeWidth <= 0) {\n          return;\n        }\n\n        context.save();\n        context.fillStyle = selectedBackgroundColor;\n\n        if (isHorizontal) {\n          context.fillRect(rangeX, 0, rangeWidth, barSize);\n        } else {\n          context.fillRect(0, rangeX, barSize, rangeWidth);\n        }\n\n        context.restore();\n      });\n    } // Draw Range Background\n\n\n    if (rangeBackgroundColor !== \"transparent\" && range[0] !== -Infinity && range[1] !== Infinity) {\n      var rangeStart = (range[0] - scrollPos) * nextZoom;\n      var rangeEnd = (range[1] - range[0]) * nextZoom;\n      context.save();\n      context.fillStyle = rangeBackgroundColor;\n\n      if (isHorizontal) {\n        context.fillRect(rangeStart, 0, rangeEnd, barSize);\n      } else {\n        context.fillRect(0, rangeStart, barSize, rangeEnd);\n      }\n\n      context.restore();\n    } // Render Segments First\n\n\n    for (var i = 0; i <= length; ++i) {\n      var value = i + minRange;\n\n      if (!isNegative && value < 0) {\n        continue;\n      }\n\n      var startValue = value * unit;\n      var startPos = (startValue - scrollPos) * nextZoom;\n\n      for (var j = 0; j < segment; ++j) {\n        var pos = startPos + j / segment * zoomUnit;\n        var value_1 = startValue + j / segment * unit;\n\n        if (pos < 0 || pos >= size || value_1 < range[0] || value_1 > range[1]) {\n          continue;\n        }\n\n        var lineSize = j === 0 ? mainLineSize : j % 2 === 0 ? longLineSize : shortLineSize;\n        var origin = 0;\n\n        switch (direction) {\n          case \"start\":\n            origin = 0;\n            break;\n\n          case \"center\":\n            origin = barSize / 2 - lineSize / 2;\n            break;\n\n          case \"end\":\n            origin = barSize - lineSize;\n            break;\n        }\n\n        var _p = isHorizontal ? [pos + lineOffset[0], origin + lineOffset[1]] : [origin + lineOffset[0], pos + lineOffset[1]],\n            x1 = _p[0],\n            y1 = _p[1];\n\n        var _q = isHorizontal ? [x1, y1 + lineSize] : [x1 + lineSize, y1],\n            x2 = _q[0],\n            y2 = _q[1];\n\n        context.moveTo(x1 + lineOffset[0], y1 + lineOffset[1]);\n        context.lineTo(x2 + lineOffset[0], y2 + lineOffset[1]);\n      }\n    }\n\n    context.stroke();\n    context.beginPath(); // Render marks\n\n    context.strokeStyle = markColor;\n    context.lineWidth = 1;\n    (marks || []).forEach(function (value) {\n      var pos = (-scrollPos + value) * nextZoom;\n\n      if (pos < 0 || pos >= size || value < range[0] || value > range[1]) {\n        return;\n      }\n\n      var _a = isHorizontal ? [pos + lineOffset[0], lineOffset[1]] : [lineOffset[0], pos + lineOffset[1]],\n          x1 = _a[0],\n          y1 = _a[1];\n\n      var _b = isHorizontal ? [x1, y1 + containerSize] : [x1 + containerSize, y1],\n          x2 = _b[0],\n          y2 = _b[1];\n\n      context.moveTo(x1 + lineOffset[0], y1 + lineOffset[1]);\n      context.lineTo(x2 + lineOffset[0], y2 + lineOffset[1]);\n    });\n    context.stroke(); // Render Labels\n\n    values.forEach(function (_a) {\n      var value = _a.value,\n          offset = _a.offset,\n          backgroundColor = _a.backgroundColor,\n          color = _a.color,\n          text = _a.text,\n          textSize = _a.textSize;\n\n      if (!isNegative && value < 0) {\n        return;\n      }\n\n      var startPos = (value - scrollPos) * nextZoom;\n\n      if (startPos < -zoomUnit || startPos >= size + unit * nextZoom || value < range[0] || value > range[1]) {\n        return;\n      }\n\n      var origin = 0;\n\n      switch (direction) {\n        case \"start\":\n          origin = 17;\n          break;\n\n        case \"center\":\n          origin = barSize / 2;\n          break;\n\n        case \"end\":\n          origin = barSize - 17;\n          break;\n      }\n\n      var _b = isHorizontal ? [startPos + alignOffset * -3, origin] : [origin, startPos + alignOffset * 3],\n          startX = _b[0],\n          startY = _b[1];\n\n      if (backgroundColor) {\n        var backgroundOffset = 0;\n\n        switch (textAlign) {\n          case \"left\":\n            backgroundOffset = 0;\n            break;\n\n          case \"center\":\n            backgroundOffset = -textSize / 2;\n            break;\n\n          case \"right\":\n            backgroundOffset = -textSize;\n            break;\n        }\n\n        context.save();\n        context.fillStyle = backgroundColor;\n\n        if (isHorizontal) {\n          context.fillRect(startX + offset[0] + backgroundOffset, 0, textSize, mainLineSize);\n        } else {\n          context.translate(0, startY + offset[1]);\n          context.rotate(-Math.PI / 2);\n          context.fillRect(backgroundOffset, 0, textSize, mainLineSize);\n        }\n\n        context.restore();\n      }\n\n      context.save();\n      context.fillStyle = color;\n\n      if (isHorizontal) {\n        context.fillText(text, startX + offset[0], startY + offset[1]);\n      } else {\n        context.translate(startX + offset[0], startY + offset[1]);\n        context.rotate(-Math.PI / 2);\n        context.fillText(text, 0, 0);\n      }\n\n      context.restore();\n    });\n    context.restore();\n  };\n\n  __proto._getRulerScale = function () {\n    var defaultPixelScale = this.props.defaultPixelScale || 2;\n\n    if (!this._rulerScale) {\n      var isHighDensity = window.devicePixelRatio > 1;\n\n      if (!isHighDensity && window.matchMedia) {\n        var mq = window.matchMedia('only screen and (min--moz-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen  and (min-device-pixel-ratio: 1.3), only screen and (min-resolution: 1.3dppx)');\n        isHighDensity = mq && mq.matches;\n      }\n\n      this._rulerScale = isHighDensity ? 3 : defaultPixelScale;\n    }\n\n    return this._rulerScale;\n  };\n\n  Ruler.defaultProps = {\n    type: \"horizontal\",\n    zoom: 1,\n    width: 0,\n    height: 0,\n    unit: 50,\n    negativeRuler: true,\n    mainLineSize: \"100%\",\n    longLineSize: 10,\n    shortLineSize: 7,\n    segment: 10,\n    direction: \"end\",\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    },\n    backgroundColor: \"#333333\",\n    font: \"10px sans-serif\",\n    textColor: \"#ffffff\",\n    textBackgroundColor: 'transparent',\n    lineColor: \"#777777\",\n    range: [-Infinity, Infinity],\n    rangeBackgroundColor: 'transparent',\n    lineWidth: 1,\n    selectedBackgroundColor: \"#555555\",\n    defaultScrollPos: 0,\n    markColor: \"#f55\",\n    marks: []\n  };\n  return Ruler;\n}(PureComponent);\n\nvar PROPERTIES = [\"type\", \"width\", \"height\", \"unit\", \"zoom\", \"direction\", \"textAlign\", \"font\", \"segment\", \"mainLineSize\", \"longLineSize\", \"shortLineSize\", \"lineOffset\", \"textOffset\", \"negativeRuler\", \"range\", \"scrollPos\", \"defaultScrollPos\", \"style\", \"backgroundColor\", \"rangeBackgroundColor\", \"lineColor\", \"textColor\", \"textBackgroundColor\", \"textFormat\", \"warpSelf\", \"selectedBackgroundColor\", \"selectedRanges\", \"defaultPixelScale\", \"useResizeObserver\", \"selectedRangesText\", \"selectedRangesTextColor\", \"selectedRangesTextOffset\", \"marks\", \"markColor\"];\nvar METHODS = [\"scroll\", \"resize\", \"getScrollPos\", \"draw\"];\n\nexport default Ruler;\nexport { METHODS, PROPERTIES };\n//# sourceMappingURL=ruler.esm.js.map\n","import Ruler, * as others from \"./index.esm\";\n\nfor (const name in others) {\n    (Ruler as any)[name] = others[name];\n}\n\nexport default Ruler;\n","import { RulerProps, RulerInterface } from \"@scena/react-ruler/declaration/types\";\nimport {\n    PROPERTIES as RULER_PROPERTIES,\n    METHODS as RULER_METHODS,\n} from \"@scena/react-ruler\";\n\nexport const PROPERTIES: Array<keyof RulerProps> = RULER_PROPERTIES;\nexport const METHODS: Array<keyof RulerInterface> = RULER_METHODS;\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { ref } from \"framework-utils\";\nimport ReactRuler from \"@scena/react-ruler\";\nimport { InnerRulerProps } from \"./types\";\n\nexport default class InnerRuler extends React.Component<InnerRulerProps, InnerRulerProps> {\n    public state: InnerRulerProps = {};\n    public ruler: ReactRuler;\n    constructor(props: InnerRulerProps) {\n        super(props);\n        this.state = this.props;\n    }\n    public render() {\n        return <ReactRuler ref={ref(this, \"ruler\")} {...this.state} />;\n    }\n}\n","import { ref, Properties } from \"framework-utils\";\nimport * as React from \"react\";\nimport { PROPERTIES } from \"./consts\";\nimport { DrawRulerOptions, RulerInterface, RulerProps } from \"@scena/react-ruler/declaration/types\";\nimport InnerRuler from \"./InnerRuler\";\nimport { ContainerProvider, renderSelf } from \"croact\";\n\n\n/**\n * A Ruler component that can draw grids and scroll infinitely.\n * @sort 1\n * @implements Ruler.RulerInterface\n */\n@Properties(PROPERTIES, (prototype, property) => {\n    Object.defineProperty(prototype, property, {\n        get() {\n            return this.getRuler().props[property];\n        },\n        set(value) {\n            this.innerRuler.setState({\n                [property]: value,\n            });\n        },\n        enumerable: true,\n        configurable: true,\n    });\n})\nclass Ruler implements RulerInterface {\n    private containerProvider: ContainerProvider | null = null;\n    private selfElement: HTMLElement | null = null;\n    private _warp = false;\n    private innerRuler!: InnerRuler;\n    /**\n     * @param - container\n     * @param {$ts:Partial<Ruler.RulerProps>} options - options\n     */\n    constructor(parentElement: HTMLElement, options: Partial<RulerProps> = {}) {\n        let selfElement!: HTMLElement;\n\n        if (options.warpSelf) {\n            delete options.warpSelf;\n            this._warp = true;\n            selfElement = parentElement;\n        } else {\n            selfElement = document.createElement(\"canvas\");\n            parentElement.appendChild(selfElement);\n        }\n        renderSelf(\n            <InnerRuler ref={ref(this, \"innerRuler\")}\n                {...options} />,\n            selfElement,\n        );\n    }\n    public scroll(scrollPos: number) {\n        this.getRuler().scroll(scrollPos);\n    }\n    public resize() {\n        this.getRuler().resize();\n    }\n    public getScrollPos() {\n        return this.getRuler().getScrollPos();\n    }\n    public draw(options: DrawRulerOptions) {\n        this.getRuler().draw(options);\n    }\n    /**\n     * Remove Ruler\n     */\n    public destroy() {\n        const selfElement = this.selfElement!;\n\n        renderSelf(\n            null,\n            selfElement!,\n            this.containerProvider,\n        );\n        if (!this._warp) {\n            selfElement?.parentElement?.removeChild(selfElement);\n        }\n        this.selfElement = null;\n        this.innerRuler = null;\n    }\n    private getRuler() {\n        return this.innerRuler.ruler;\n    }\n}\n\nexport default Ruler;\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","name","Ruler","_super","__extends","TypeError","String","__","this","constructor","_this","apply","arguments","state","scrollPos","width","height","_zoom","_rulerScale","_observer","_checkResize","resize","create","__proto","render","props","zoom","createElement","ref","style","componentDidMount","canvas","defaultScrollPos","canvasElement","context","getContext","alpha","canvasContext","useResizeObserver","ResizeObserver","observe","box","componentDidUpdate","componentWillUnmount","_a","disconnect","getScrollPos","scroll","draw","nextZoom","rulerScale","_getRulerScale","offsetWidth","offsetHeight","options","_b","_c","marks","_d","selectedRanges","_e","segment","_f","unit","type","backgroundColor","lineColor","textColor","textBackgroundColor","direction","_h","negativeRuler","textFormat","_j","range","Infinity","rangeBackgroundColor","selectedBackgroundColor","_k","lineWidth","selectedRangesText","_l","selectedRangesTextColor","_m","selectedRangesTextOffset","_o","markColor","isHorizontal","isNegative","font","textAlign","textOffset","containerSize","mainLineSize","convertUnitSize","concat","longLineSize","shortLineSize","lineOffset","clearRect","rect","fillStyle","fill","save","scale","strokeStyle","textBaseline","translate","beginPath","size","zoomUnit","minRange","Math","floor","length","ceil","alignOffset","max","indexOf","barSize","values","i","value","text","textSize","measureText","push","color","offset","forEach","selectedRange","rangeStart","rangeEnd","min","rangeX","rangeWidth","startPos","endPos","findLast","index","prevValue","prevTextSize","prevStartPos","splice","fillRect","restore","startValue","j","pos","value_1","lineSize","origin","_p","x1","y1","_q","x2","y2","moveTo","lineTo","stroke","startX","startY","backgroundOffset","rotate","PI","fillText","mq","isHighDensity","defaultPixelScale","window","devicePixelRatio","matchMedia","matches","defaultProps","PureComponent","PROPERTIES","METHODS","React","ReactRuler","parentElement","selfElement","warpSelf","_warp","document","appendChild","renderSelf","InnerRuler","getRuler","containerProvider","removeChild","innerRuler","ruler","property","defineProperty","get","set","setState","enumerable","configurable","others"],"mappings":"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"}